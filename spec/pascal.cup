/*
  pascal.cup
*/

/* ----------------------Preliminary Declarations Section--------------------*/

import compiler.util.*;

/* Parser code to change the way the parser reports errors (include
   line and column number of the error). */

 parser code  {:
  public void report_error(String message, Object info){
    StringBuffer m = new StringBuffer("Error: " + message + "\n");
    System.err.print(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
 :};

/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).  */

terminal  ARRAY, BEGIN, CASE, CONST;
terminal  String AND, NOT, OR, MINUS, STAR, PLUS;
terminal  String DIV, MOD, SLASH;
terminal  DO, DOWNTO, ELSE, END, FILE, FOR, FORWARD, FUNCTION, GOTO, IF;
terminal  IMPLEMENTATION, IN, INTERFACE, LABEL, NIL;
terminal  OF, PACKED, PROCEDURE, PROGRAM, RECORD, REPEAT, SET, EXTERNAL;
terminal  STRING, THEN, TO, TYPE, UNIT, UNTIL, USES, VAR, WHILE, WITH, XOR;
terminal  SEMICOLON, DOT;
terminal  String IDENTIFIER, CHARACTER_STRING;
terminal  ASSIGNMENT;
terminal  COLON, COMMA, DIGSEQ;
terminal  DOTDOT, EQUAL;
terminal  GE, GT, LBRAC, LE, LPAREN, LT;
terminal  NOTEQUAL, PBEGIN, PFILE, RBRAC;
terminal  REALNUMBER, RPAREN, STARSTAR, UPARROW;
terminal  INTEGER, BOOLEAN, REAL, CHAR, TRUE, FALSE;



/* Non terminals used in the grammar section. */

non terminal program, program_heading;
non terminal identifier_list, for_designator, while_designator;
non terminal block, module;
non terminal label_declaration_part, label_list, label, constant_definition_part;
non terminal constant_list, constant_definition;
non terminal cexpression, csimple_expression;
non terminal cterm, cfactor, cexponentiation, cprimary, constant, non_string;
non terminal type_definition_part, type_definition_list, type_definition;
non terminal type_denoter, result_type;
non terminal new_type, new_ordinal_type, enumerated_type, subrange_type, new_structured_type;
non terminal structured_type, array_type, index_list, index_type, ordinal_type, component_type;
non terminal record_type, record_section_list, record_section, variant_part, variant_selector;
non terminal variant_list, variant, case_constant_list, case_constant, tag_field, tag_type;
non terminal set_type, base_type, file_type, new_pointer_type, domain_type, variable_declaration_part;
non terminal variable_declaration_list, variable_declaration, procedure_and_function_declaration_part;
non terminal proc_or_func_declaration_list, proc_or_func_declaration, procedure_declaration;
non terminal procedure_heading, directive;
non terminal formal_parameter_list, formal_parameter_section_list;
non terminal formal_parameter_section, value_parameter_specification, variable_parameter_specification;
non terminal procedural_parameter_specification, functional_parameter_specification;
non terminal procedure_identification, function_identification, direction;
non terminal procedure_block, function_declaration, function_heading;
non terminal function_block, statement_part, compound_statement, statement_sequence, statement, open_statement;
non terminal closed_statement, non_labeled_closed_statement, non_labeled_open_statement, repeat_statement;
non terminal open_while_statement, closed_while_statement, open_for_statement, closed_for_statement;
non terminal open_with_statement, closed_with_statement, open_if_statement, closed_if_statement;
non terminal assignment_statement;
non terminal variable_access;
non terminal indexed_variable, index_expression_list, index_expression;
non terminal field_designator, procedure_statement;
non terminal params, actual_parameter_list;
non terminal actual_parameter;
non terminal goto_statement, case_statement, case_index, case_list_element_list, case_list_element;
non terminal control_variable, initial_value, final_value, record_variable_list;
non terminal boolean_expression, expression, simple_expression, term, factor, exponentiation, primary;
non terminal unsigned_constant, unsigned_number, unsigned_integer, unsigned_real, function_designator;
non terminal set_constructor, member_designator_list, member_designator, relop;
non terminal identifier, addop, mulop, sign;
non terminal semicolon, comma;

/* -------------Precedence and Associatively of Terminals Section----------- */

/*
  Precedence of non terminals could be defined here.  If you do define
  precedence here you won't need to worry about precedence in the
  Grammar Section, i.e. that TIMES should have a higher precedence
  than PLUS.

  The precedence defined here would look something like this where the
  lower line always will have higher precedence than the line before it.

  precedence left PLUS, MINUS;
  precedence left TIMES, DIVIDE;
*/

  precedence left STAR, DIV;

/* ----------------------------Gramatica-------------------- */

   start with program;

   program ::=
   {:Logger.print("Program");:} program_heading semicolon block DOT ;

   program_heading ::=
   {:Logger.print("Program Heading - line 1");:} PROGRAM identifier |
   {:Logger.print("Program Heading - line 2");:} PROGRAM identifier LPAREN identifier_list RPAREN;

   identifier_list ::= identifier_list comma IDENTIFIER | IDENTIFIER;

   block ::=
   {:Logger.print("Block");:} label_declaration_part constant_definition_part type_definition_part
	 variable_declaration_part procedure_and_function_declaration_part statement_part;

   module ::=
   {:Logger.print("Module");:} constant_definition_part type_definition_part variable_declaration_part
   procedure_and_function_declaration_part;

   label_declaration_part ::=
   {:Logger.print("Label Declaration Part - line 1");:} LABEL label_list semicolon |
   {:Logger.print("Label Declaration Part - line 2");:}  error semicolon |
   {:Logger.print("Label Declaration Part - line 3");:} ;

   label_list ::=
   {:Logger.print("Label List - line 1");:} label_list comma label |
   {:Logger.print("Label List - line 2");:} label;

   label ::= {:Logger.print("Label");:} DIGSEQ;

   constant_definition_part ::=
   {:Logger.print("Constant Definition Part - line 1");:} CONST constant_list |
   {:Logger.print("Constant Definition Part - line 2");:};

   constant_list ::=
   {:Logger.print("Constant List - line 1");:} constant_list constant_definition |
   {:Logger.print("Constant List - line 2");:} constant_definition;

   constant_definition ::=
   {:Logger.print("Constant Definition - line 1");:} identifier EQUAL cexpression semicolon |
   {:Logger.print("Constant Definition - line 2");:} error semicolon;

   cexpression ::=
   {:Logger.print("Cexpression - line 1");:} csimple_expression |
   {:Logger.print("Cexpression - line 2");:} csimple_expression relop csimple_expression;

   csimple_expression ::=
   {:Logger.print("Csimple Expression - line 1");:} cterm |
   {:Logger.print("Csimple Expression - line 2");:} csimple_expression addop cterm;

   cterm ::=
   {:Logger.print("Cterm - line 1");:} cfactor |
   {:Logger.print("Cterm - line 2");:} cterm mulop cfactor;

   cfactor ::=
   {:Logger.print("Cfactor - line 1");:} sign cfactor |
   {:Logger.print("Cfactor - line 2");:} cexponentiation;

   cexponentiation ::=
   {:Logger.print("Cexponentiation - line 1");:} cprimary |
   {:Logger.print("Cexponentiation - line 2");:} cprimary  STARSTAR cexponentiation;

   cprimary ::=
   {:Logger.print("Cprimary - line 1");:} identifier |
   {:Logger.print("Cprimary - line 2");:} LPAREN cexpression RPAREN |
   {:Logger.print("Cprimary - line 3");:} unsigned_constant |
   {:Logger.print("Cprimary - line 4");:} NOT cprimary;

   constant ::=
   {:Logger.print("Constant - line 1");:} non_string |
   {:Logger.print("Constant - line 2");:} sign non_string |
   {:Logger.print("Constant - line 3");:} CHARACTER_STRING;

   sign ::=
   {:Logger.print("Sign - line 1");:} PLUS |
   {:Logger.print("Sign - line 2");:} MINUS;

   non_string ::=
   {:Logger.print("Non String - line 1");:} DIGSEQ |
   {:Logger.print("Non String - line 2");:} identifier|
   {:Logger.print("Non String - line 3");:} REALNUMBER;

   type_definition_part ::=
   {:Logger.print("Type Definition Part - line 1");:} TYPE type_definition_list |
   {:Logger.print("Type Definition Part - line 2");:} ;

   type_definition_list ::=
   {:Logger.print("Type Definition List - line 1");:} type_definition_list type_definition |
   {:Logger.print("Type Definition List - line 2");:} type_definition;

   type_definition ::=
   {:Logger.print("Type Definition - line 1");:} identifier EQUAL type_denoter semicolon |
   {:Logger.print("Type Definition - line 2");:} error semicolon;

   type_denoter ::=
   {:Logger.print("Type Denoter - line 1");:} IDENTIFIER |
   {:Logger.print("Type Denoter - line 2");:} new_type |
   {:Logger.print("Type Denoter - line 3");:} STRING |
   {:Logger.print("Type Denoter - line 4");:} INTEGER |
   {:Logger.print("Type Denoter - line 5");:} CHAR |
   {:Logger.print("Type Denoter - line 6");:} REAL |
   {:Logger.print("Type Denoter - line 7");:} BOOLEAN
   ;

   new_type ::=
   {:Logger.print("New Type - line 1");:} new_ordinal_type |
   {:Logger.print("New Type - line 2");:} new_structured_type |
   {:Logger.print("New Type - line 3");:} new_pointer_type;

   new_ordinal_type ::=
   {:Logger.print("New Ordinal Type - line 1");:} enumerated_type |
   {:Logger.print("New Ordinal Type - line 2");:} subrange_type;

   enumerated_type ::=
   {:Logger.print("Enumarated Type - line 1");:} LPAREN identifier_list RPAREN;

   subrange_type ::=
   {:Logger.print("Subrange Type - lne 1");:}  constant DOTDOT constant;

   new_structured_type ::=
   {:Logger.print("New Structured Type - line 1");:} structured_type |
   {:Logger.print("New Structured Type - line 2");:} PACKED structured_type;

   structured_type ::=
   {:Logger.print("Structured Type - line 1");:} array_type |
   {:Logger.print("Structured Type - line 2");:} record_type |
   {:Logger.print("Structured Type - line 3");:} set_type |
   {:Logger.print("Structured Type - line 4");:} file_type;

   array_type ::=
   {:Logger.print("Array Type - line 1");:} ARRAY LBRAC index_list RBRAC OF component_type;

   index_list ::=
   {:Logger.print("Index List - line 1");:} index_list comma index_type |
   {:Logger.print("Index List - line 2");:} index_type;

   index_type ::=
   {:Logger.print("Index type - line 1");:} ordinal_type ;

   ordinal_type ::=
   {:Logger.print("Ordinal Type - line 1");:} new_ordinal_type |
   {:Logger.print("Ordinal Type - line 2");:} identifier;

   component_type ::=
   {:Logger.print("Component Type - line 1");:} type_denoter;

   record_type ::=
   {:Logger.print("Record Type - line 1");:} RECORD record_section_list END |
   {:Logger.print("Record Type - line 2");:} RECORD record_section_list semicolon variant_part END |
   {:Logger.print("Record Type - line 3");:} RECORD variant_part END;

   record_section_list ::=
   {:Logger.print("Record Section List - line 1");:} record_section_list semicolon record_section |
   {:Logger.print("Record Section List - line 2");:} record_section;

   record_section ::=
   {:Logger.print("Record Section - line 1");:} identifier_list COLON type_denoter;

   variant_part ::=
   {:Logger.print("Variant Part - line 1");:} CASE variant_selector OF variant_list semicolon |
   {:Logger.print("Variant Part - line 2");:} CASE variant_selector OF variant_list |
   {:Logger.print("Variant Part - line 3");:} ;

   variant_selector ::=
   {:Logger.print("Variant Selector - line 1");:} tag_field COLON tag_type |
   {:Logger.print("Variant Selector - line 2");:} tag_type;

   variant_list ::=
   {:Logger.print("Variant List - line 1");:} variant_list semicolon variant |
   {:Logger.print("Variant List - line 2");:} variant;

   variant ::=
   {:Logger.print("Variant - line 1");:} case_constant_list COLON LPAREN record_section_list RPAREN |
   {:Logger.print("Variant - line 2");:} case_constant_list COLON LPAREN record_section_list semicolon variant_part RPAREN |
   {:Logger.print("Variant - line 3");:} case_constant_list COLON LPAREN variant_part RPAREN;

   case_constant_list ::=
   {:Logger.print("Case Constant List - line 1");:} case_constant_list comma case_constant |
   {:Logger.print("Case Constant List - line 2");:} case_constant;

   case_constant ::=
   {:Logger.print("Case Constant - line 1");:} constant |
   {:Logger.print("Case Constant - line 2");:} constant DOTDOT constant;

   tag_field ::=
   {:Logger.print("Tag Field - line 1");:} identifier;

   tag_type ::=
   {:Logger.print("Tag Type - line 1");:} identifier;

   set_type ::=
   {:Logger.print("Set Type - line 1");:} SET OF base_type;

   base_type ::=
   {:Logger.print("Base Type - line 1");:} ordinal_type ;

   file_type ::=
   {:Logger.print("File Type - line 1");:} PFILE OF component_type;

   new_pointer_type ::=
   {:Logger.print("New Pointer Type - line 1");:} UPARROW domain_type;

   domain_type ::=
   {:Logger.print("Domain Type - line 1");:} identifier;

   variable_declaration_part ::=
   {:Logger.print("Variable Declaration Part- line 1");:} VAR variable_declaration_list |
   {:Logger.print("Variable Declaration Part - line 2");:} ;

   variable_declaration_list ::= variable_declaration_list variable_declaration | variable_declaration;

   variable_declaration ::=
   {:Logger.print("Variable Declaration - line 1");:} identifier_list COLON type_denoter semicolon |
   {:Logger.print("Variable Declaration - line 2");:} error semicolon;

   procedure_and_function_declaration_part ::=
   {:Logger.print("Procedure and Function Declaration Part Declaration List - line 1");:} proc_or_func_declaration_list semicolon |
   {:Logger.print("Procedure and Function Declaration Part Declaration List - line 2");:} ;

   proc_or_func_declaration_list ::=
   {:Logger.print("Procedure or Function Declaration List - line 1");:} proc_or_func_declaration_list semicolon proc_or_func_declaration |
   {:Logger.print("Procedure or Function Declaration List - line 2");:} proc_or_func_declaration;

   proc_or_func_declaration ::=
   {:Logger.print("Procedure or Function Declaration List - line 1");:} procedure_declaration |
   {:Logger.print("Procedure or Function Declaration List - line 2");:} function_declaration;

   procedure_declaration ::=
   {:Logger.print("Procedure Declaration - line 1");:} procedure_heading semicolon directive |
   {:Logger.print("Procedure Declaration - line 2");:} procedure_heading semicolon procedure_block;

   procedure_heading ::=
   {:Logger.print("procedure_heading - line 1");:} procedure_identification
 |	{:Logger.print("procedure_heading - line 2");:} procedure_identification formal_parameter_list;

  directive ::=
   {:Logger.print("directive - line 1");:} FORWARD
 | {:Logger.print("directive - line 2");:} EXTERNAL;

  formal_parameter_list ::=
   {:Logger.print("formal_parameter_list - line 1");:} LPAREN formal_parameter_section_list RPAREN;

  formal_parameter_section_list ::=
   {:Logger.print("formal_parameter_section_list - line 1");:} formal_parameter_section_list semicolon formal_parameter_section
 | {:Logger.print("formal_parameter_section_list - line 2");:} formal_parameter_section
 ;

  formal_parameter_section ::=
   {:Logger.print("formal_parameter_section - line 1");:} value_parameter_specification
 | {:Logger.print("formal_parameter_section - line 2");:} variable_parameter_specification
 | {:Logger.print("formal_parameter_section - line 3 ");:} procedural_parameter_specification
 | {:Logger.print("formal_parameter_section - line 4");:} functional_parameter_specification;

  value_parameter_specification ::=
   {:Logger.print("value_parameter_specification - line 1");:} identifier_list COLON type_denoter
 ;

  variable_parameter_specification ::=
   {:Logger.print("variable_parameter_specification - line 1");:} VAR identifier_list COLON type_denoter
 ;

  procedural_parameter_specification ::=
   {:Logger.print("procedural_parameter_specification - line 1");:} procedure_heading
 ;

  functional_parameter_specification ::=
   {:Logger.print("functional_parameter_specification - line 1");:} function_heading
 ;

  procedure_identification ::=
   {:Logger.print("procedure_identification - line 1");:} PROCEDURE identifier
 ;

  procedure_block ::=
   {:Logger.print("procedure_block - line 1");:} block
 ;

  function_declaration ::=
   {:Logger.print("function_declaration - line 1");:} function_heading semicolon directive
 | {:Logger.print("function_declaration - line 2 ");:} function_identification semicolon function_block
 | {:Logger.print("function_declaration - line 3");:} function_heading semicolon function_block ;

  function_heading ::=
   {:Logger.print("function_heading - line 1");:} FUNCTION identifier COLON result_type
 | {:Logger.print("function_heading - line 2");:} function_identification formal_parameter_list COLON result_type ;

 result_type ::=
   {:Logger.print("result_type - line 1 ");:}type_denoter
 ;

  function_identification ::=
   {:Logger.print("function_identification - line 1");:} FUNCTION identifier
 ;

  function_block ::=
   {:Logger.print("function_block - line 1");:} block
 ;

  statement_part ::=
   {:Logger.print("statement_part - line 1");:} compound_statement
 ;

  compound_statement ::=
   {:Logger.print("compound_statement - line 1");:} BEGIN statement_sequence END
   ;

  statement_sequence ::= statement_sequence semicolon statement | statement;

  statement ::=
   {:Logger.print("statement - line 1");:} open_statement
 | {:Logger.print("statement - line 2");:} closed_statement
 ;

  open_statement ::=
   {:Logger.print("open_statement - line 1");:} label COLON non_labeled_open_statement
|   {:Logger.print("open_statement - line 2");:} non_labeled_open_statement
 ;

  closed_statement ::=
   {:Logger.print("closed_statement - line 1 ");:} label COLON non_labeled_closed_statement
|   {:Logger.print("closed_statement - line 2");:} non_labeled_closed_statement
 ;

  non_labeled_closed_statement ::=
   {:Logger.print("non_labeled_closed_statement - line 1");:} assignment_statement
|   {:Logger.print("non_labeled_closed_statement - line 2");:} procedure_statement
|   {:Logger.print("non_labeled_closed_statement - line 3");:} goto_statement
|   {:Logger.print("non_labeled_closed_statement - line 4");:} compound_statement
|   {:Logger.print("non_labeled_closed_statement - line 5");:} case_statement
|   {:Logger.print("non_labeled_closed_statement - line 6");:} repeat_statement
|   {:Logger.print("non_labeled_closed_statement - line 7");:} closed_with_statement
|   {:Logger.print("non_labeled_closed_statement - line 8");:} closed_if_statement
|   {:Logger.print("non_labeled_closed_statement - line 9");:} closed_while_statement
|   {:Logger.print("non_labeled_closed_statement - line 10");:} closed_for_statement
|   {:Logger.print("non_labeled_closed_statement - line 11");:}
 ;

  non_labeled_open_statement ::=
   {:Logger.print("non_labeled_open_statement - line 1");:} open_with_statement
|   {:Logger.print("non_labeled_open_statement - line 2");:} open_if_statement
|   {:Logger.print("non_labeled_open_statement - line 3");:} open_while_statement
|   {:Logger.print("non_labeled_open_statement - line 4");:} open_for_statement
 ;

  repeat_statement ::=
   {:Logger.print("repeat_statement - line 1");:} REPEAT statement_sequence UNTIL boolean_expression
 ;

  while_designator ::=
   {:Logger.print("while_designator - line 1");:} WHILE boolean_expression
 ;

  open_while_statement ::=
   {:Logger.print("open_while_statement - line 1");:} while_designator DO open_statement
 ;

  closed_while_statement ::=
   {:Logger.print("closed_while_statement - line 1");:} while_designator DO closed_statement
 ;

  for_designator ::=
   {:Logger.print("for_designator - line 1");:} FOR control_variable ASSIGNMENT initial_value direction final_value
 ;

  open_for_statement ::=
   {:Logger.print("open_for_statement - line 1");:} for_designator DO open_statement
 ;

  closed_for_statement ::=
   {:Logger.print("closed_for_statement - line 1");:} for_designator DO closed_statement
 ;

  open_with_statement ::=
   {:Logger.print("open_with_statement - line 1");:} WITH record_variable_list DO open_statement
 ;

  closed_with_statement ::=
   {:Logger.print("closed_with_statement - line 1");:} WITH record_variable_list DO closed_statement
 ;

  open_if_statement ::=
   {:Logger.print("open_if_statement - line 1");:} IF boolean_expression THEN statement
|   {:Logger.print("open_if_statement - line 2");:} IF boolean_expression THEN closed_statement ELSE open_statement
 ;

  closed_if_statement ::=
   {:Logger.print("closed_if_statement - line 1");:} IF boolean_expression THEN closed_statement ELSE closed_statement
 ;

  assignment_statement ::=
   {:Logger.print("assignment_statement - line 1");:} variable_access ASSIGNMENT expression
 ;

  variable_access ::=
   {:Logger.print("variable_access - line 1");:} identifier
|   {:Logger.print("variable_access - line 2");:} indexed_variable
|   {:Logger.print("variable_access - line 3");:} field_designator
|   {:Logger.print("variable_access - line 4");:} variable_access UPARROW;

  indexed_variable ::=
   {:Logger.print("indexed_variable - line 1");:} variable_access LBRAC index_expression_list RBRAC
 ;

  index_expression_list ::=
   {:Logger.print("index_expression_list - line 1");:} index_expression_list comma index_expression
|   {:Logger.print("index_expression_list - line 2");:} index_expression
 ;

  index_expression ::=
   {:Logger.print("index_expression - line 1");:} expression
 ;

  field_designator ::=
   {:Logger.print("field_designator - line 1");:} variable_access DOT identifier
 ;

  procedure_statement ::=
   {:Logger.print("procedure_statement - line 1");:} identifier params
|   {:Logger.print("procedure_statement - line 2");:} identifier;

  params ::=
   {:Logger.print("params - line 1");:} LPAREN actual_parameter_list RPAREN
 ;

  actual_parameter_list ::=
   {:Logger.print("actual_parameter_list - line 1");:} actual_parameter_list comma actual_parameter
 ;

 /*
  * this forces you to check all this to be sure that only write and
  * writeln use the 2nd and 3rd forms, you really can't do it easily in
  * the grammar, especially since write and writeln aren't reserved
  */
  actual_parameter ::=
   {:Logger.print("actual_parameter - line 1");:} expression
|   {:Logger.print("actual_parameter - line 2");:} expression COLON expression
|   {:Logger.print("actual_parameter - line 3");:} expression COLON expression COLON expression;

  goto_statement ::=
   {:Logger.print("goto_statement - line 1");:} GOTO label
 ;

  case_statement ::=
   {:Logger.print("case_statement - line 1");:} CASE case_index OF case_list_element_list END
|   {:Logger.print("case_statement - line 2");:} CASE case_index OF case_list_element_list SEMICOLON END
 ;

case_index ::=
   {:Logger.print("case_index");:} expression
 ;

case_list_element_list ::=
   {:Logger.print("case_list_element_list - line 1");:} case_list_element_list semicolon case_list_element
|   {:Logger.print("case_list_element_list - line 2");:} case_list_element
 ;

case_list_element ::=
   {:Logger.print("case_list_element - line 1");:} case_constant_list COLON statement
 ;

control_variable ::=
   {:Logger.print("control_variable - line 1");:} identifier
 ;

initial_value ::=
   {:Logger.print("initial_value - line 1");:} expression
 ;

direction ::=
   {:Logger.print("direction - line 1");:} TO
|   {:Logger.print("direction - line 2");:} DOWNTO ;

final_value ::=
   {:Logger.print("final_value - line 1");:} expression
 ;

record_variable_list ::=
   {:Logger.print("record_variable_list - line 1");:} record_variable_list comma variable_access
|   {:Logger.print("record_variable_list - line 2");:} variable_access;

boolean_expression ::=
   {:Logger.print("boolean_expression - line 1");:} expression
 ;

expression ::=
   {:Logger.print("expression - line 1");:} simple_expression
|   {:Logger.print("expression - line 2");:} simple_expression relop simple_expression;

simple_expression ::=
   {:Logger.print("simple_expression - line 1");:} term
|  {:Logger.print("simple_expression - line 2");:} simple_expression addop term
 ;

term ::=
   {:Logger.print("term - line 1");:} factor
|   {:Logger.print("term - line 2");:} term mulop factor
 ;

factor ::=
   {:Logger.print("factor - line 1");:} sign factor
|  {:Logger.print("factor - line 2");:} exponentiation
;

exponentiation ::=
   {:Logger.print("exponentiation - line 1");:} primary
|   {:Logger.print("exponentiation - line 2");:} primary STARSTAR exponentiation
;

primary ::=
   {:Logger.print("primary - line 1");:} variable_access
|   {:Logger.print("primary - line 2");:} unsigned_constant
|   {:Logger.print("primary - line 3");:} function_designator
|   {:Logger.print("primary - line 4");:} set_constructor
|   {:Logger.print("primary - line 5");:} LPAREN expression RPAREN
|   {:Logger.print("primary - line 6");:} NOT primary
|   {:Logger.print("primary - line 7");:} TRUE
|   {:Logger.print("primary - line 8");:} FALSE
;

unsigned_constant ::=
   {:Logger.print("unsigned_constant - line 1");:} unsigned_number
|   {:Logger.print("unsigned_constant - line 2");:} CHARACTER_STRING
|   {:Logger.print("unsigned_constant - line 3");:} NIL;

unsigned_number ::=
   {:Logger.print("unsigned_number - line 1");:} unsigned_integer
|   {:Logger.print("unsigned_number - line 2");:} unsigned_real
 ;

unsigned_integer ::=
   {:Logger.print("unsigned_integer - line 1");:} DIGSEQ
 ;

unsigned_real ::=
   {:Logger.print("unsigned_real - line 1");:} REALNUMBER
 ;

function_designator ::=
   {:Logger.print("function_designator - line 1");:} identifier params
 ;

set_constructor ::=
   {:Logger.print("set_constructor - line 1");:} LBRAC member_designator_list RBRAC
|   {:Logger.print("set_constructor - line 2");:} LBRAC RBRAC;

member_designator_list ::=
   {:Logger.print("member_designator_list - line 1");:} member_designator_list comma member_designator
|   {:Logger.print("member_designator_list - line 2");:} member_designator;

member_designator ::=
   {:Logger.print("member_designator - line 1");:} member_designator DOTDOT expression
|  {:Logger.print("member_designator - line 2");:} expression;

addop ::=
   {:Logger.print("addop - line 1");:} PLUS
|   {:Logger.print("addop - line 2");:} MINUS
|   {:Logger.print("addop - line 3");:} OR;

mulop ::=
   {:Logger.print("mulop - line 1");:} STAR
|   {:Logger.print("mulop - line 2");:} SLASH
|   {:Logger.print("mulop - line 3");:} DIV
|   {:Logger.print("mulop - line 4");:} MOD
|   {:Logger.print("mulop - line 5");:} AND;

relop ::=
   {:Logger.print("relop - line 1");:} EQUAL
|   {:Logger.print("relop - line 2");:} NOTEQUAL
|   {:Logger.print("relop - line 3");:} LT
|   {:Logger.print("relop - line 4");:} GT
|   {:Logger.print("relop - line 5");:} LE
|   {:Logger.print("relop - line 6");:} GE
|   {:Logger.print("relop - line 7");:} IN
 ;

identifier ::=
   {:Logger.print("identifier - line 1");:} IDENTIFIER
 ;

semicolon ::=
   {:Logger.print("semicolon - line 1");:} SEMICOLON
 ;

comma ::=
 {:Logger.print("comma - line 1");:} COMMA
 ;
