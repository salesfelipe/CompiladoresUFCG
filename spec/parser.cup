import compiler.util.*;

parser code  {:
  public static final String ANSI_RESET = "\u001B[0m";
  public static final String ANSI_RED = "\u001B[31m";
  public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer(ANSI_RED + "Error on: \n");

   if (info instanceof compiler.core.JavaSymbol) {
      compiler.core.JavaSymbol s = ((compiler.core.JavaSymbol) info);

      m.append( s.toString()  + "\n");
   }

   m.append("Message : " + message  + "\n" + ANSI_RESET);

   System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException(ANSI_RED + "Fatal Syntax Error" + ANSI_RESET);
  }
:};

terminal PROGRAM, BEGIN, END, AND, ARRAY, LABEL, CONST, TYPE, VAR, FORWARD, PROCEDURE, FUNCTION, USES, GOTO, WHILE, DO, PACKED,
RECORD, SET, FILE;
terminal UNTIL, REPEAT, FOR, TO, DOWNTO, IF, THEN, ELSE, CASE, OF, WITH;
terminal DOT, LPAREN, RPAREN, COMMA, SEMICOLON, COLON, ASSIGNMENT, LBRAC, RBRAC, DOTDOT;
terminal java.lang.String IDENTIFIER;
terminal INTEGER_LITERAL, FLOATING_POINT_LITERAL, PLUS, MINUS, EQUALS, STRING_LITERAL,  NOT, NIL, NOTEQUAL, LT, GREATERT, LE, GE, IN, OR,
DIV, MOD, STAR, UPARRAOW, SLASH, INTEGER, BOOLEAN, IMPLEMENTATION, INTERFACE, EXTERNAL,FALSE, TRUE, UNIT, REAL, CHAR, XOR, STARSTAR, UPARROW, GT, EQUAL, STRING;

non terminal compilation_unit, program_heading, block, identifier_list, identifier_list_aux, component_variable_aux;
non terminal declaration_part, procedure_and_function_declaration_part, program_heading_aux;
non terminal label_declaration_part, constant_definition_part, type_definition, type_definition_part, variable_declaration_part, uses_definition_part;
non terminal label, label_optionals, formal_parameter_section, aux_formal_parameter_section, procedure_identifier;
non terminal constant_definition, constant_definition_aux, constant, optional_formal_parameter_list, formal_parameter_list;
non terminal statement_part, procedure_identification, function_heading, function_identification, function_body, function_identifier;
non terminal sign, sign_optional, digit_sequence, integer_number, compiler_defined_directives, statement_sequence, result_type, statement, aux_statement_sequence, optional_label, simple_statement, structured_statement, assignment_statement, procedure_statement, goto_statement, variable, expression, actual_parameter_list, compound_statement, repetitive_statement, conditional_statement, with_statement, while_statement, repeat_statement, for_statement, variable_identifier, initial_expression, final_expression, if_statement, case_statement, case_limb, case_limb_aux, case_label_list, constant_aux, record_variable, record_variable_aux;
non terminal type, variable_declaration, procedure_declaration, function_declaration, procedure_heading, procedure_body, directive;
non terminal type_identifier, constant_identifier, number, string, real_number, simple_type, structured_type, pointer_type,
actual_parameter, actual_value, actual_variable, actual_function, actual_procedure, actual_parameter_aux;
non terminal value_parameter_section, variable_parameter_section, procedure_parameter_section, function_parameter_section, parameter_type,
conformant_array_schema, packed_conformant_array_schema, unpacked_conformant_array_schema, bound_specification, bound_specification_aux;
non terminal ordinal_type_identifier, simple_expression, expression_aux, relational_operator, term, simple_expression_aux, addition_operator,
factor, term_aux, multiplication_operator, set, bound_identifier, function_designator, entire_variable, component_variable;
non terminal referenced_variable, field_identifier, indexed_variable, field_designator, file_buffer, array_variable, expression_list,
element_list, element_list_aux, optional_actual_parameter_list, file_variable;
non terminal field_list_aux, fixed_part, fixed_part_aux, variant_part, record_section, tag_field, variant, variant_part_aux;
non terminal subrange_type, enumerated_type, lower_bound, upper_bound, unpacked_structured_type, array_type, record_type, set_type,
file_type, index_type, array_type_aux, element_type, field_list, base_type, file_component_type;
non terminal pointer_variable, variable_list, expression_list_aux, simple_statement_aux, variable_declaration_part_aux, primary_type;

start with compilation_unit;

compilation_unit ::=
	program_heading block DOT
;

program_heading ::=
  {:Logger.print("Program Heading");:} PROGRAM IDENTIFIER program_heading_aux
;

program_heading_aux ::=
  {:Logger.print("Program Heading Aux - line 1");:} LPAREN identifier_list RPAREN SEMICOLON |
  {:Logger.print("Program Heading Aux - line 2");:} SEMICOLON
;

block ::=
  {:Logger.print("Block");:} declaration_part statement_part
;

declaration_part ::=
    {:Logger.print("Declaration Part");:}
    label_declaration_part uses_definition_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part
;

statement_part ::=
  {:Logger.print("Statement Part");:} BEGIN statement_sequence END
;

label_declaration_part ::=
  {:Logger.print("Label Declaration Part - line 1");:} |
  {:Logger.print("Label Declaration Part - line 2");:} LABEL label label_optionals SEMICOLON
;

label_optionals ::=
    {:Logger.print("Label optionals - line 1");:} |
    {:Logger.print("Label optionals - line 2");:} COMMA label label_optionals
;

constant_definition_part ::=
  {:Logger.print("Constant definition part - line 1");:} |
  {:Logger.print("Constant definition part - line 2");:} CONST constant_definition SEMICOLON constant_definition_aux
;

constant_definition ::=
  {:Logger.print("Constant Definition");:} IDENTIFIER EQUALS constant
;

constant_definition_aux ::=
    {:Logger.print("Constant Definition aux - line 1");:} |
    {:Logger.print("Constant Definition aux - line 2");:} constant_definition SEMICOLON constant_definition_aux
;

type_definition_part ::=
  {:Logger.print("Type definition part - line 1");:} |
  {:Logger.print("Type definition part - line 2");:} TYPE type_definition SEMICOLON type_definition_part |
  {:Logger.print("Type definition part - line 3");:} TYPE type_definition SEMICOLON
;

type_definition ::=
  {:Logger.print("Type definition");:} IDENTIFIER EQUALS type
;

uses_definition_part ::=
  {:Logger.print("Uses definition Part - line 1");:} |
  {:Logger.print("Uses definition Part - line 2");:} USES IDENTIFIER SEMICOLON
;

variable_declaration_part ::=
  {:Logger.print("Variable declaration part - line 1");:} |
  {:Logger.print("Variable declaration part - line 2");:} VAR variable_declaration SEMICOLON variable_declaration_part_aux
;

variable_declaration_part_aux ::=
  {:Logger.print("Variable declaration part Aux - line 1");:} |
  {:Logger.print("Variable declaration part Aux - line 2");:} variable_declaration_part
;

variable_declaration ::=
  {:Logger.print("Variable declaration");:} identifier_list COLON type
;

procedure_and_function_declaration_part ::=
    {:Logger.print("Procedure and function declaration part - line 1");:}
	| {:Logger.print("Procedure and function declaration part - line 2");:} procedure_declaration SEMICOLON procedure_and_function_declaration_part
	| {:Logger.print("Procedure and function declaration part - line 3");:} function_declaration SEMICOLON procedure_and_function_declaration_part
;

procedure_declaration ::=
	 {:Logger.print("Procedure declaration - line 1");:} procedure_heading SEMICOLON procedure_body |
	 {:Logger.print("Procedure declaration - line 2");:} procedure_heading SEMICOLON directive |
	 {:Logger.print("Procedure declaration - line 3");:} procedure_identification SEMICOLON procedure_body
;


procedure_body ::=
  {:Logger.print("Procedure body");:} block
;

function_declaration ::=
  {:Logger.print("Function declaration - line 1");:} function_heading SEMICOLON function_body |
	{:Logger.print("Function declaration - line 2");:} function_heading SEMICOLON directive |
	{:Logger.print("Function declaration - line 3");:} function_identification SEMICOLON function_body
;

function_body ::=
  {:Logger.print("Function Body");:} block
;

directive ::=
  {:Logger.print("Directive - line 1");:} FORWARD |
	{:Logger.print("Directive - line 2");:} compiler_defined_directives
;

statement_part ::=
  {:Logger.print("Statement Part");:} BEGIN statement_sequence END
;

optional_formal_parameter_list ::=
  {:Logger.print("Optional formal parameter list - line 1");:} |
  {:Logger.print("Optional formal parameter list - line 2");:} formal_parameter_list
;

formal_parameter_list ::=
  {:Logger.print("Formal parameter list");:} LPAREN formal_parameter_section aux_formal_parameter_section RPAREN
;

aux_formal_parameter_section ::=
  {:Logger.print("Aux formal parameter section - line 1");:} |
  {:Logger.print("Aux formal parameter section - line 2");:} SEMICOLON formal_parameter_section aux_formal_parameter_section
;

procedure_identification ::=
  {:Logger.print("Procedure Identification");:} PROCEDURE procedure_identifier
;

procedure_identifier ::=
  {:Logger.print("Procedure identifier");:} IDENTIFIER
;

function_identifier ::=
  {:Logger.print("Function Identifier");:} IDENTIFIER
;

function_heading ::=
  {:Logger.print("Function Heading");:} FUNCTION IDENTIFIER optional_formal_parameter_list COLON result_type
;

result_type ::=
  {:Logger.print("Result type");:} type
;

function_identification ::=
  {:Logger.print("Function Identificaton");:} FUNCTION function_identifier
;

compiler_defined_directives ::=
  {:Logger.print("Compiler directives");:}
;

statement_sequence ::=
  {:Logger.print("Statement sequence");:} statement SEMICOLON aux_statement_sequence
;

aux_statement_sequence ::=
  {:Logger.print("Aux statement sequence - line 1 -> ");:} |
  {:Logger.print("Aux statement sequence - line 2 -> statement ; aux_statement_sequence");:} statement SEMICOLON aux_statement_sequence
;

statement ::=
  {:Logger.print("Statement - line 1");:} optional_label simple_statement |
  {:Logger.print("Statement - line 2");:} optional_label structured_statement
;

optional_label ::=
  {:Logger.print("Optional Label - line 1");:} |
  {:Logger.print("Optional Label - line 2");:} label COLON
;

simple_statement ::=
  {:Logger.print("Simple Statement - line 1");:} |
  {:Logger.print("Simple Statement - line 2");:} IDENTIFIER simple_statement_aux |
  {:Logger.print("Simple Statement - line 3");:} goto_statement
;

simple_statement_aux ::=
  {:Logger.print("Simple Statement Aux - line 1");:} procedure_statement |
  {:Logger.print("Simple Statement Aux - line 2");:} assignment_statement
;

assignment_statement ::=
  {:Logger.print("Assignment Statement");:} ASSIGNMENT expression
;

procedure_statement ::=
  {:Logger.print("Procedure statement");:} actual_parameter_list
;

goto_statement ::=
  {:Logger.print("Go to statement");:} GOTO label
;

structured_statement ::=
  {:Logger.print("Structured statement - line 1");:} compound_statement |
  {:Logger.print("Structured statement - line 2");:} repetitive_statement |
  {:Logger.print("Structured statement - line 3");:} conditional_statement |
  {:Logger.print("Structured statement - line 4");:} with_statement
;

compound_statement ::=
  {:Logger.print("Compound statement");:} BEGIN statement_sequence END
;

repetitive_statement ::=
  {:Logger.print("Repetitive Statment - line 1");:} while_statement |
  {:Logger.print("Repetitive Statment - line 2");:} repeat_statement |
  {:Logger.print("Repetitive Statment - line 3");:} for_statement
;

while_statement ::=
  {:Logger.print("While statement Part");:} WHILE expression DO statement
;

repeat_statement ::=
  {:Logger.print("Repeat statement");:} REPEAT statement_sequence UNTIL expression
;

for_statement ::=
  {:Logger.print("For Statement - line 1");:} FOR variable_identifier ASSIGNMENT initial_expression TO final_expression DO statement |
  {:Logger.print("For Statement - line 2");:} FOR variable_identifier ASSIGNMENT initial_expression DOWNTO final_expression DO statement
;

initial_expression ::=
  {:Logger.print("Initial Expression");:} expression
;

final_expression ::=
  {:Logger.print("Final Expression");:} expression
;

conditional_statement ::=
  {:Logger.print("Conditional Statement - line 1");:} if_statement |
  {:Logger.print("Conditional Statement - line 2");:} case_statement
;

if_statement ::=
  {:Logger.print("If Statement - line 1");:} IF expression THEN statement |
  {:Logger.print("If Statement - line 2");:} IF expression THEN statement ELSE statement
;

case_statement ::=
  {:Logger.print("Case Statement - line 1");:} CASE expression OF case_limb case_limb_aux END |
  {:Logger.print("Case Statement - line 2");:} CASE expression OF case_limb case_limb_aux SEMICOLON END
;

case_limb_aux ::=
  {:Logger.print("Case Limb Aux - line 1");:} |
  {:Logger.print("Case Limb Aux - line 2");:} SEMICOLON case_limb case_limb_aux
;

case_limb ::=
  {:Logger.print("Case Limb");:} case_label_list COLON statement
;

case_label_list ::=
  {:Logger.print("Case Label List");:} constant constant_aux
;

with_statement ::=
  {:Logger.print("With Statement");:} WITH record_variable record_variable_aux DO statement
;

record_variable_aux ::=
  {:Logger.print("Record Variable Aux - line 1");:} |
  {:Logger.print("Record Variable Aux - line 2");:} COLON record_variable record_variable_aux
;

constant_aux ::=
  {:Logger.print("Constant Aux - line 1");:} |
  {:Logger.print("Constant Aux - line 2");:} COLON constant constant_aux
;

label ::=
  {:Logger.print("Label");:} integer_number
;

actual_parameter_list ::=
  {:Logger.print("Actual Parameter List - line 1");:} |
  {:Logger.print("Actual Parameter List - line 2");:} LPAREN actual_parameter  actual_parameter_aux RPAREN
;

actual_parameter ::=
  {:Logger.print("Actual Parameter - line 1");:} actual_value |
  {:Logger.print("Actual Parameter - line 2");:} actual_variable |
  {:Logger.print("Actual Parameter - line 3");:} actual_procedure |
  {:Logger.print("Actual Parameter - line 4");:} actual_function
;

actual_parameter_aux ::=
  {:Logger.print("Actual Parameter Aux - line 1");:} |
  {:Logger.print("Actual Parameter Aux - line 2");:} COMMA actual_parameter actual_parameter_aux
;

actual_value ::=
  {:Logger.print("Actual Value");:} expression
;

actual_procedure ::=
  {:Logger.print("Actual Procedure");:} procedure_identifier
;

actual_function ::=
  {:Logger.print("Actual Function");:} function_identifier
;

formal_parameter_section ::=
  {:Logger.print("Formal parameter section - line 1");:} value_parameter_section |
  {:Logger.print("Formal parameter section - line 2");:} variable_parameter_section |
  {:Logger.print("Formal parameter section - line 3");:} procedure_parameter_section |
  {:Logger.print("Formal parameter section - line 4");:} function_parameter_section
;

value_parameter_section ::=
  {:Logger.print("Value parameter section");:} identifier_list COLON parameter_type
;

variable_parameter_section ::=
  {:Logger.print("Variable parameter section");:} VAR identifier_list COLON parameter_type
;

procedure_parameter_section ::=
  {:Logger.print("Procedure parameter section");:} procedure_heading
;

function_parameter_section ::=
  {:Logger.print("Function parameter section");:} function_heading
;

parameter_type ::=
  {:Logger.print("Parameter type - line 1");:} type
;

conformant_array_schema ::=
  {:Logger.print("Conformant array schema - line 1");:} packed_conformant_array_schema |
  {:Logger.print("Conformant array schema - line 2");:} unpacked_conformant_array_schema
;

packed_conformant_array_schema ::=
  {:Logger.print("Packed conformant array schema");:} PACKED ARRAY LBRAC bound_specification RBRAC OF type_identifier
;

unpacked_conformant_array_schema ::=
  {:Logger.print("Unpacked conformant array schema - line 1");:} ARRAY LBRAC bound_specification bound_specification_aux RBRAC OF type_identifier |
  {:Logger.print("Unpacked conformant array schema - line 2");:} ARRAY LBRAC bound_specification bound_specification_aux RBRAC OF conformant_array_schema
;

bound_specification_aux ::=
  {:Logger.print("Bound specification aux - line 1");:} |
  {:Logger.print("Bound specification aux - line 2");:} SEMICOLON bound_specification bound_specification_aux
;

bound_specification ::=
  {:Logger.print("Bound Specification");:} IDENTIFIER DOTDOT IDENTIFIER COLON ordinal_type_identifier
;

ordinal_type_identifier ::=
  {:Logger.print("Ordinal type identifier");:} type_identifier
;

expression ::=
  {:Logger.print("Expression");:} simple_expression
;

expression_aux ::=
  {:Logger.print("Expression Aux - line 2");:} |
  {:Logger.print("Expression Aux - line 3");:} simple_expression |
  {:Logger.print("Expression Aux - line 1");:} relational_operator
;

simple_expression ::=
  {:Logger.print("Simple Expression");:} sign_optional term simple_expression_aux
;

simple_expression_aux ::=
  {:Logger.print("Simple Expression Aux - line 1");:} |
  {:Logger.print("Simple Expression Aux - line 2");:} addition_operator term simple_expression_aux
;

term ::=
  {:Logger.print("Term");:} factor term_aux
;

term_aux ::=
  {:Logger.print("Term Aux - line 1");:} |
  {:Logger.print("Term Aux - line 2");:} multiplication_operator factor term_aux
;

factor ::=
  {:Logger.print("Factor - line 1");:} variable |
  {:Logger.print("Factor - line 2");:} number |
  {:Logger.print("Factor - line 3");:} string |
  {:Logger.print("Factor - line 4");:} set |
  {:Logger.print("Factor - line 5");:} NIL |
  {:Logger.print("Factor - line 6");:} constant_identifier |
  {:Logger.print("Factor - line 7");:} bound_identifier |
  {:Logger.print("Factor - line 8");:} function_designator |
  {:Logger.print("Factor - line 9");:} LPAREN expression RPAREN |
  {:Logger.print("Factor - line 10");:} NOT factor
;

relational_operator ::=
  {:Logger.print("Relational Operator - line 1");:} EQUALS |
  {:Logger.print("Relational Operator - line 2");:} NOTEQUAL |
  {:Logger.print("Relational Operator - line 3");:} LT |
  {:Logger.print("Relational Operator - line 4");:} LE |
  {:Logger.print("Relational Operator - line 5");:} GREATERT |
  {:Logger.print("Relational Operator - line 6");:} GE |
  {:Logger.print("Relational Operator - line 7");:} IN
;

addition_operator ::=
  {:Logger.print("Addition Operator - line 1");:} PLUS |
  {:Logger.print("Addition Operator - line 2");:} MINUS |
  {:Logger.print("Addition Operator - line 3");:} OR
;

multiplication_operator ::=
  {:Logger.print("Multiplication Operator - line 1");:} STAR |
  {:Logger.print("Multiplication Operator - line 2");:} DIV |
  {:Logger.print("Multiplication Operator - line 3");:} SLASH |
  {:Logger.print("Multiplication Operator - line 4");:} MOD |
  {:Logger.print("Multiplication Operator - line 5");:} AND
;

variable ::=
  {:Logger.print("Variable - line 1");:} variable_identifier |
  {:Logger.print("Variable - line 2");:} component_variable
;

entire_variable ::=
  {:Logger.print("Entire Variable - line 1");:} variable_identifier |
  {:Logger.print("Entire Variable - line 2");:} field_identifier
;


component_variable ::=
  {:Logger.print("Component Variable - line 1");:} variable_identifier component_variable_aux  // LBRAC expression_list RBRAC |
;

component_variable_aux ::=
  {:Logger.print("Component Variable Aux - line 1");:} LBRAC expression_list RBRAC
| {:Logger.print("Component Variable Aux - line 2");:} DOT field_identifier
| {:Logger.print("Component Variable Aux - line 3");:} UPARRAOW
;

indexed_variable ::=
  {:Logger.print("Indexed Variable");:} array_variable LBRAC expression_list RBRAC
;

field_designator ::=
  {:Logger.print("Field Designator");:} record_variable DOT field_identifier
;

set ::=
  {:Logger.print("Set");:} LBRAC element_list RBRAC
;

element_list ::=
  {:Logger.print("Element List - line 1");:} |
  {:Logger.print("Element List - line 2");:} expression element_list_aux
;

element_list_aux ::=
  {:Logger.print("Element List Aux - line 1");:} |
  {:Logger.print("Element List Aux - line 2");:} COMMA expression element_list_aux
;

function_designator ::=
  {:Logger.print("Function Designator");:} function_identifier optional_actual_parameter_list
;

optional_actual_parameter_list ::=
  {:Logger.print("Optional Actual Parameter List - line 1");:} |
  {:Logger.print("Optional Actual Parameter List - line 2");:} actual_parameter_list
;

file_buffer ::=
  {:Logger.print("File Bufffer");:} file_variable UPARRAOW
;


// Types

type ::=
  {:Logger.print("Type - line 1");:} simple_type |
  {:Logger.print("Type - line 2");:} structured_type |
  {:Logger.print("Type - line 3");:} pointer_type |
  {:Logger.print("Type - line 4");:} primary_type
;

primary_type ::=
  {:Logger.print("Primary Type - STRING");:} STRING |
  {:Logger.print("Primary Type - INTEGER");:} INTEGER |
  {:Logger.print("Primary Type - CHAR");:} CHAR |
  {:Logger.print("Primary Type - REAL");:} REAL |
  {:Logger.print("Primary Type - BOOLEAN");:} BOOLEAN |
  {:Logger.print("Primary Type - ID");:}type_identifier
;


simple_type ::=
  {:Logger.print("Simple Type - line 1");:} subrange_type |
  {:Logger.print("Simple Type - line 2");:} enumerated_type
;

enumerated_type ::=
  {:Logger.print("Enumerated Type");:} LPAREN identifier_list RPAREN
;

subrange_type ::=
  {:Logger.print("Subrange Type");:} lower_bound DOTDOT upper_bound
;

lower_bound ::=
  {:Logger.print("Lower Bound");:} constant
;

upper_bound ::=
  {:Logger.print("Upper Bound");:} constant
;

structured_type ::=
  {:Logger.print("Structure Type - line 1");:} unpacked_structured_type |
  {:Logger.print("Structure Type - line 2");:} PACKED unpacked_structured_type
;

unpacked_structured_type ::=
  {:Logger.print("Unpacked Structured Type - line 1");:} array_type |
  {:Logger.print("Unpacked Structured Type - line 2");:} record_type |
  {:Logger.print("Unpacked Structured Type - line 3");:} set_type |
  {:Logger.print("Unpacked Structured Type - line 4");:} file_type
;

array_type ::=
  {:Logger.print("Array Type");:} ARRAY LBRAC index_type array_type_aux RBRAC OF element_type
;

array_type_aux ::=
  {:Logger.print("Array Type Aux - line 1");:} |
  {:Logger.print("Array Type Aux - line 2");:} COMMA index_type array_type_aux
;

index_type ::=
  {:Logger.print("Index Type");:} simple_type
;

element_type ::=
  {:Logger.print("Element Type");:} type
;

record_type ::=
  {:Logger.print("Record Type");:} RECORD field_list END
;

set_type ::=
  {:Logger.print("Set Type");:} SET OF base_type
;

base_type ::=
  {:Logger.print("Base Type");:} type
;

file_type ::=
  {:Logger.print("File Type");:} FILE OF file_component_type
;

file_component_type ::=
  {:Logger.print("File Component Type");:} type
;

pointer_type ::=
  {:Logger.print("Pointer Type");:} UPARRAOW type_identifier
;

// Record Fields

field_list ::=
  {:Logger.print("Field List - line 1");:} |
  {:Logger.print("Field List - line 2");:} field_list_aux |
  {:Logger.print("Field List - line 3");:} field_list_aux SEMICOLON
;

field_list_aux ::=
  {:Logger.print("Field List Aux- line 1");:} fixed_part SEMICOLON variant_part |
  {:Logger.print("Field List Aux- line 2");:} fixed_part |
  {:Logger.print("Field List Aux- line 3");:} variant_part
;

fixed_part ::=
  {:Logger.print("Fixed Part");:} record_section fixed_part_aux
;

fixed_part_aux ::=
  {:Logger.print("Fixed Part Aux - line 1");:} |
  {:Logger.print("Fixed Part Aux - line 2");:} SEMICOLON record_section fixed_part_aux
;

record_section ::=
  identifier_list COLON type
;

variant_part ::=
  {:Logger.print("Variant Part");:} CASE tag_field type_identifier OF variant variant_part_aux
;

variant_part_aux ::=
  {:Logger.print("Variant Part Aux - line 1");:} |
  {:Logger.print("Variant Part Aux - line 2");:} SEMICOLON variant
;

tag_field ::=
  {:Logger.print("Tag Field - line 1");:} |
  {:Logger.print("Tag Field - line 2");:} IDENTIFIER COLON
;

variant ::=
  {:Logger.print("Variant");:} case_label_list COLON LPAREN field_list RPAREN
;

// Input Output

// end IN/OUT

// Variable and Identifier Categories

file_variable ::=
  {:Logger.print("File Variable");:} variable
;

referenced_variable ::=
  {:Logger.print("Referenced Variable");:} pointer_variable UPARRAOW
;

record_variable ::=
  {:Logger.print("Record Variable");:} variable
;

pointer_variable ::=
  {:Logger.print("Pointer Variable");:} variable
;

actual_variable ::=
  {:Logger.print("Actual Variable");:} variable
;

array_variable ::=
  {:Logger.print("Array Variable");:} variable_identifier
;

field_identifier ::=
  {:Logger.print("Field Identifier");:} IDENTIFIER
;

constant_identifier ::=
  {:Logger.print("Constant Identifier");:} IDENTIFIER
;

variable_identifier ::=
  {:Logger.print("Variable Identifier");:} IDENTIFIER
;

type_identifier ::=
  {:Logger.print("Type Identifier");:} IDENTIFIER
;

procedure_identifier ::=
  {:Logger.print("Procedure Identifier");:} IDENTIFIER
;

function_identifier ::=
  {:Logger.print("Function Identifier");:} IDENTIFIER
;

bound_identifier ::=
  {:Logger.print("Bound Identifier");:} IDENTIFIER
;

// Low Level Definitions

variable_list ::=
 // WTF?
;

identifier_list ::=
  {:Logger.print("Identifier List");:} IDENTIFIER identifier_list_aux
;

identifier_list_aux ::=
  {:Logger.print("Identifier List Aux - line 1");:} |
  {:Logger.print("Identifier List Aux - line 2");:} COMMA IDENTIFIER identifier_list_aux
;

expression_list ::=
  {:Logger.print("Expression List");:} expression expression_list_aux
;

expression_list_aux ::=
  {:Logger.print("Expression List Aux - line 1");:} |
  {:Logger.print("Expression List Aux - line 2");:} COMMA expression expression_list_aux
;

number ::=
  {:Logger.print("Number - line 1");:} integer_number |
  {:Logger.print("Number - line 2");:} real_number
;

integer_number ::=
  {:Logger.print("Integer Number" );:} digit_sequence
;

digit_sequence ::=
  {:Logger.print("Digit Sequence");:} sign_optional INTEGER_LITERAL
;

real_number ::=
  {:Logger.print("Real Number");:} FLOATING_POINT_LITERAL
;

sign ::=
  {:Logger.print("Sign - line 1");:} PLUS |
  {:Logger.print("Sign - line 2");:} MINUS
;

sign_optional ::=
  {:Logger.print("Sign Optional - line 1");:} |
  {:Logger.print("Sign Optional - line 2");:} sign
;

string ::=
  {:Logger.print("String");:} STRING_LITERAL
;

constant_aux ::=
  constant_identifier | number
;

type_identifier ::=
  {:Logger.print("Type Identifier");:} IDENTIFIER
;
