import compiler.util.*;

parser code  {:
 public void report_error(String message, Object info){
   StringBuffer m = new StringBuffer("Error: " + message + "\n");
   System.err.print(m);
 }

 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Fatal Syntax Error");
 }
:};

terminal PROGRAM, BEGIN, END, AND, ARRAY, LABEL, CONST, TYPE, VAR, FORWARD, PROCEDURE, FUNCTION, USES, GOTO, WHILE, DO;
terminal UNTIL, REPEAT, FOR, TO, DOWNTO, IF, THEN, ELSE, CASE, OF, WITH;
terminal DOT, LPAREN, RPAREN, COMMA, SEMICOLON, COLON, COLONEQUALS;
terminal java.lang.String IDENTIFIER;
terminal INTEGER_LITERAL, PLUS, MINUS, EQUALS;

non terminal compilation_unit, program_heading, block, identifier_list, identifier_list_aux;
non terminal declaration_part, declaration_part_optional, declaration_part_required, procedure_and_function_declaration_part;
non terminal label_declaration_part, constant_definition_part, type_definition, type_definition_part, variable_declaration_part, uses_definition_part;
non terminal label, label_optionals, formal_parameter_section, aux_formal_parameter_section, procedure_identifier;
non terminal constant_definition, constant_definition_aux, constant, optional_formal_parameter_list, formal_parameter_list;
non terminal statement_part, procedure_identification, function_heading, function_identification, function_body, function_identifier;
non terminal sign, sign_optional, digit_sequence, integer_number, compiler_defined_directives, statement_sequence, result_type, statement, aux_statement_sequence, optional_label, simple_statement, structured_statement, assignment_statement, procedure_statement, goto_statement, variable, expression, actual_parameter_list, compound_statement, repetitive_statement, conditional_statement, with_statement, while_statement, repeat_statement, for_statement, variable_identifier, initial_expression, final_expression, if_statement, case_statement, case_limb, case_limb_aux, case_label_list, constant_aux, record_variable, record_variable_aux;
non terminal type, variable_declaration, procedure_declaration, function_declaration, procedure_heading, procedure_body, directive;
non terminal type_identifier, constant_identifier, number, string, real_number, simple_type, structured_type, pointer_type;

start with compilation_unit;

compilation_unit ::=
	program_heading block DOT
;

// Programs and Blocks

program_heading ::=  {:Logger.print("Program Heading");:}
   PROGRAM IDENTIFIER identifier_list SEMICOLON
;

block ::= {:Logger.print("Block");:}
	declaration_part statement_part
;

declaration_part ::= {:Logger.print("Declaration Part");:}
	declaration_part_optional declaration_part_required
;

declaration_part_optional ::= {:Logger.print("Declaration Part optional");:}
	| label_declaration_part
  | uses_definition_part
	| constant_definition_part
	| type_definition_part
	| variable_declaration_part
;

declaration_part_required ::= {:Logger.print("Declaration Part required");:}
	procedure_and_function_declaration_part
;

procedure_and_function_declaration_part ::= {:Logger.print("");:}
	| procedure_declaration SEMICOLON procedure_and_function_declaration_part
	| function_declaration SEMICOLON procedure_and_function_declaration_part
;

label_declaration_part ::=
	LABEL label label_optionals SEMICOLON
;

label_optionals ::=
	| COMMA label label_optionals
;

constant_definition_part ::=
	CONST constant_definition SEMICOLON constant_definition_aux
;

constant_definition ::=
	IDENTIFIER EQUALS constant
;

constant_definition_aux ::=
	| constant_definition SEMICOLON constant_definition_aux
;

type_definition_part ::=
	TYPE type_definition SEMICOLON | TYPE type_definition SEMICOLON type_definition_part
;

type_definition ::=
	IDENTIFIER EQUALS type
;

uses_definition_part ::=
  USES IDENTIFIER SEMICOLON
;

variable_declaration_part ::=
	VAR variable_declaration SEMICOLON | VAR variable_declaration SEMICOLON variable_declaration_part
;

variable_declaration ::=
	identifier_list COLON type
;

procedure_declaration ::=
	procedure_heading SEMICOLON procedure_body |
	procedure_heading SEMICOLON directive |
	procedure_identification SEMICOLON procedure_body
;

procedure_body ::=
	block
;

function_declaration ::=
	function_heading SEMICOLON function_body |
	function_heading SEMICOLON directive |
	function_identification SEMICOLON function_body
;

function_body ::=
	block
;

directive ::=
	FORWARD |
	compiler_defined_directives
;

statement_part ::=
	BEGIN statement_sequence END
;

// END BLOCK AND PROGRAMS

// Procedure and Function Definitions

procedure_heading ::=
  PROCEDURE IDENTIFIER optional_formal_parameter_list
;

optional_formal_parameter_list ::=
  | formal_parameter_list
;

formal_parameter_list ::=
  LPAREN formal_parameter_section aux_formal_parameter_section RPAREN
;

aux_formal_parameter_section ::=
  | SEMICOLON formal_parameter_section aux_formal_parameter_section
;

procedure_identification ::=
  PROCEDURE procedure_identifier
;

procedure_identifier ::=
  IDENTIFIER
;

function_identifier ::=
  IDENTIFIER
;

function_heading ::=
  FUNCTION IDENTIFIER optional_formal_parameter_list COLON result_type
;

result_type ::=
  type_identifier
;

function_identification ::=
  FUNCTION function_identifier
;


compiler_defined_directives ::=
;

// Statements

statement_sequence ::=
  statement | statement aux_statement_sequence
;

aux_statement_sequence ::=
| SEMICOLON statement
| SEMICOLON statement aux_statement_sequence
;

statement ::=
  optional_label simple_statement
| optional_label structured_statement
;

optional_label ::=
| label COLON
;

simple_statement ::=
| assignment_statement
| procedure_statement
| goto_statement
;

assignment_statement ::=
  variable COLONEQUALS expression
| function_identifier COLONEQUALS expression
;

// TODO expression ::=

procedure_statement ::=
  procedure_identifier actual_parameter_list
| procedure_identifier
;

goto_statement ::=
  GOTO label
;

structured_statement ::=
  compound_statement
| repetitive_statement
| conditional_statement
| with_statement
;

compound_statement ::=
  BEGIN statement_sequence END
;

repetitive_statement ::=
  while_statement
| repeat_statement
| for_statement
;

while_statement ::=
  WHILE expression DO statement
;

repeat_statement ::=
  REPEAT statement_sequence UNTIL expression
;

for_statement ::=
  FOR variable_identifier COLONEQUALS initial_expression TO final_expression DO statement
| FOR variable_identifier COLONEQUALS initial_expression DOWNTO final_expression DO statement
;

initial_expression ::=
  expression
;

final_expression ::=
  expression
;

conditional_statement ::=
  if_statement
| case_statement
;

if_statement ::=
  IF expression THEN statement
| IF expression THEN statement ELSE statement
;

case_statement ::=
  CASE expression OF case_limb case_limb_aux END
| CASE expression OF case_limb case_limb_aux SEMICOLON END
;

case_limb_aux ::=
| SEMICOLON case_limb case_limb_aux
;

case_limb ::=
  case_label_list COLON statement
;

case_label_list ::=
  constant constant_aux
;

with_statement ::=
  WITH record_variable record_variable_aux DO statement
;

record_variable_aux ::=
| COLON record_variable record_variable_aux
;

constant_aux ::=
| COLON constant constant_aux
;

label ::=
  integer_number
;



constant ::=
	sign_optional constant_identifier
	| sign_optional number
	| string
;

constant_identifier ::=
	IDENTIFIER
;

identifier_list ::=
	| LPAREN identifier_list_aux RPAREN
;

identifier_list_aux ::=
	| IDENTIFIER
	| IDENTIFIER COMMA identifier_list_aux
;

number ::=
	integer_number | real_number
;

integer_number ::=
	digit_sequence
;

digit_sequence ::=
	sign_optional INTEGER_LITERAL
;

sign ::= PLUS | MINUS;

sign_optional ::=
	| sign
;

type ::=
	simple_type | structured_type | pointer_type | type_identifier
;

real_number ::=
;

string ::=
;

simple_type ::=
;

structured_type ::=
;

pointer_type ::=
;

type_identifier ::=
  IDENTIFIER
;
